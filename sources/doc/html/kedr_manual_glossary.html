<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Glossary</title><link rel="stylesheet" type="text/css" href="kedr-doc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="KEDR 0.5 Reference Manual"><link rel="up" href="index.html" title="KEDR 0.5 Reference Manual"><link rel="prev" href="kedr_manual_reference.html" title="6. KEDR Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Glossary</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="kedr_manual_reference.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr></div><div class="glossary"><div class="titlepage"><div><div><h2 class="title"><a name="kedr_manual_glossary"></a>Glossary</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that the terms <em class="firstterm">driver</em> and <em class="firstterm">kernel module</em> have differences in meaning in some cases. However, unless specifically stated, they are used interchangeably in this manual as the synonyms for <em class="firstterm">loadable kernel module</em>. The meaning is as it is defined <a class="ulink" href="http://en.wikipedia.org/wiki/Loadable_kernel_module" target="_top">in Wikipedia</a>.
</p></div><dl><dt><a name="kedr"></a><span class="emphasis"><em>KEDR</em></span></dt><dd><p>
<span class="emphasis"><em>KEDR</em></span> stands for <span class="emphasized">KE</span>rnel-mode <span class="emphasized">D</span>rivers in <span class="emphasized">R</span>untime. KEDR framework provides the means to collect data about the operation of a kernel module in runtime and analyze these data. The tools provided by the framework rely heavily on the means to intercept the function calls made by the kernel module under analysis. 
    </p></dd><dt><a name="target_module"></a><span class="emphasis"><em>Target module</em></span></dt><dd><p>
A kernel module to be analyzed. 
    </p></dd><dt><a name="target_function"></a><span class="emphasis"><em>Target function</em></span></dt><dd><p>
To perform analysis of the target module, it can be necessary to intercept function calls the module makes. The functions the calls to which are to be intercepted are called <em class="firstterm">target functions</em>. For example, to analyze how memory is allocated and freed by the target module, one may need to intercept calls to <code class="code">__kmalloc()</code>, <code class="code">kfree()</code>, etc.
    </p><p>
The target functions can be exported by the <em class="firstterm">base kernel</em> (<em class="firstterm"><span class="quote">“<span class="quote">kernel proper</span>”</span></em>) or by some kernel modules.
    </p><p>
By choosing appropriate <a class="link" href="kedr_manual_glossary.html#payload_module">payload modules</a>, the user may select the groups of functions the calls to which are to be intercepted.
    </p></dd><dt><a name="trampoline"></a><span class="emphasis"><em>Trampoline</em></span></dt><dd><p>
KEDR system instruments the <a class="link" href="kedr_manual_glossary.html#target_module">target module</a> so that the calls to the <a class="link" href="kedr_manual_glossary.html#target_function">target functions</a> are replaced in it with the calls to special <em class="firstterm">trampoline functions</em>. 
    </p><p>
A trampoline function has the same signature as the corresponding target function. When the trampoline function is called, it receives the same argument values as the target function would. The trampoline function calls <a class="link" href="kedr_manual_glossary.html#pre_handler">pre handlers</a>, <a class="link" href="kedr_manual_glossary.html#replacement_function">replacement function</a> and <a class="link" href="kedr_manual_glossary.html#post_handler">post handlers</a> that can be provided by the user via custom <a class="link" href="kedr_manual_glossary.html#payload_module">payload modules</a>. If no replacement function is provided, the target function will be called instead.
    </p></dd><dt><a name="replacement_function"></a><span class="emphasis"><em>Replacement function</em></span></dt><dd><p>
A replacement function is a user-provided function that is called <span class="emphasis"><em>instead</em></span> of the corresponding <a class="link" href="kedr_manual_glossary.html#target_function">target function</a>.
    </p><p>
When the replacement function is called, it receives the same argument values as the target function would and additional argument of type <span class="nobreak"><span class="type"><a class="type" href="kedr_manual_reference.html#payload_api.function_call_info">struct kedr_function_call_info *</a></span></span>. Return value of the replacement function is interpreted as a value returned by the target function (that is, the caller of the target function will get this value as if it has been returned by the target function).
    </p><p>
The last argument of the replacement function currently contains only <code class="varname">return_address</code> field, which is set to the address of the instruction to which target function would return control. Note that this field should be used instead of expressions like <code class="code">__builtin_return_address(0)</code>.  This is because a replacement function is actually called by a trampoline function rather than directly from the place where the target is called. What is usually needed, however, is not the return address of a replacement function but rather the return address of the target function (to output call stack, etc.).
    </p><p>
A replacement function may do some actions instead of calling the target function. The visible effect of these actions may be the same as effect of target function call or they can be different. Another usage of replacement function is to call the target function (or to perform other actions) conditionally. Example: <span class="quote">“<span class="quote">if the value of <code class="code">size</code> argument is less than 1024, call <code class="code">__kmalloc()</code> as usual, otherwise return <code class="code">NULL</code> as if<code class="code">__kmalloc()</code> has failed to allocate <code class="code">size</code> bytes</span>”</span>. Such conditional calls controlled by user-defined scenarios are a key point in the fault simulation facilities provided by KEDR. 
    </p><p>
If a replacement function should call (unconditionally) target function along with perfoming other actions, it is better to use <a class="link" href="kedr_manual_glossary.html#pre_handler">pre handler</a> and/or <a class="link" href="kedr_manual_glossary.html#post_handler">post handler</a> instead of a replacement function. The point is, several payload modules that need to process the same target function may work together only if no more than one of them replaces this function with another one. The usage of pre and post handlers, however, is not limited this way.
    </p><p>
The exact signature of the replacement function is described in <a class="xref" href="kedr_manual_reference.html#payload_api.replace_pair">Section 6.1.5, “struct kedr_replace_pair”</a>. Apart from having the correct signature, KEDR system imposes no additional restrictions on the replacement functions. 
    </p></dd><dt><a name="pre_handler"></a><span class="emphasis"><em>Pre handler</em></span></dt><dd><p>
A pre handler is a user-provided function which is called <span class="emphasis"><em>before</em></span> corresponding <a class="link" href="kedr_manual_glossary.html#target_function">target function</a>.
    </p><p>
When the pre handler is called, it receives the same argument values as the target function will receive later and additional argument of type <span class="nobreak"><span class="type"><a class="type" href="kedr_manual_reference.html#payload_api.function_call_info">struct kedr_function_call_info *</a></span></span>.    
    </p><p>
The last argument of the replacement function currently contains only <code class="varname">return_address</code> field, which is set to the address of the instruction to which target function would return control. Note that this field should be used instead of expressions like <code class="code">__builtin_return_address(0)</code>. This is because a handler function is actually called by a trampoline function rather than directly from the place where the target is called. What is usually needed, however, is not the return address of a handler but rather the return address of the target function (to output call stack, etc.).
    </p><p>
A pre handler may, for example, output the arguments of the function to a trace. Although post handlers seem more suitable for this purpose because they may also output return value of the function, there are situations when a pre handler is preferable (see, for example, <a class="xref" href="kedr_manual_extend.html#happens_before_parameter">Section 5.3, “<span class="quote">“<span class="quote">trace.happensBefore</span>”</span> Parameter for Call Monitoring”</a>).
    </p><p>
Another possible goal of a pre handler could be to change the data passes to the function via pointers. The handler cannot change the argument's value itself (this change would be lost when the handler returns), but when the argument is a pointer to some data, the handler can change the latter.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Care should be taken if a pre handler provided by a payload module changes some arguments of the target function as described above and some other payload modules provide pre handlers for the same function. KEDR itself does not forbid such usage. It is unspecified in which order the pre handlers for a function are invoked. So it is undefined whether one pre handler will see the initial parameters or the ones changed by a pre handler from another payload module.
        </p><p>
In the future, pre handlers and post handlers registered by different payload modules may be ordered in some way.
        </p></div><p>
The exact signature of a pre handler is described in <a class="xref" href="kedr_manual_reference.html#payload_api.pre_pair">Section 6.1.3, “struct kedr_pre_pair”</a>. Apart from having the correct signature, KEDR system imposes no additional restrictions on the pre handlers. 
    </p></dd><dt><a name="post_handler"></a><span class="emphasis"><em>Post handler</em></span></dt><dd><p>
A post handler is a user-provided function which is called <span class="emphasis"><em>after</em></span> the corresponding <a class="link" href="kedr_manual_glossary.html#target_function">target function</a>.
    </p><p>
When the post handler is called, it gets the same argument values as the target function has received before, along with the return value of the target function (if the latter returns value) and an additional argument of type <span class="nobreak"><span class="type"><a class="type" href="kedr_manual_reference.html#payload_api.function_call_info">struct kedr_function_call_info *</a></span></span>.    
    </p><p>
The last argument of the replacement function currently contains only <code class="varname">return_address</code> field, which is set to the address of the instruction to which target function would return control. Note that this field should be used instead of expressions like <code class="code">__builtin_return_address(0)</code>. This is because a handler function is actually called by a trampoline function rather than directly from the place where the target is called. What is usually needed, however, is not the return address of a handler but rather the return address of the target function (to output call stack, etc.).
    </p><p>
One common usage of a post handler is to collect function arguments and return value and write them to a trace or a log file or the like.
    </p><p>
The exact signature of a post handler is described in <a class="xref" href="kedr_manual_reference.html#payload_api.post_pair">Section 6.1.4, “struct kedr_post_pair”</a>. Apart from having the correct signature, KEDR system imposes no additional restrictions on the post handlers. 
    </p></dd><dt><a name="payload_module"></a><span class="emphasis"><em>Payload module</em></span></dt><dd><p>
A payload module is a kernel module that actually contains <a class="link" href="kedr_manual_glossary.html#pre_handler">pre handlers</a>, <a class="link" href="kedr_manual_glossary.html#post_handler">post handlers</a> and <a class="link" href="kedr_manual_glossary.html#replacement_function">replacement functions</a> for a particular group of target functions. The core components of KEDR use the information about these handlers when instrumenting the target module.
    </p><p>
It is payload modules rather than KEDR core that define which data should be collected about the target module, how the execution of the latter should be altered (if it should be at all), etc. Different sets of payload modules may allow to perform different kinds of analysis of the target module.
    </p><p>
Currently, KEDR provides payload modules for several types of data collection and analysis operations. Custom payload modules can be provided by the user. As long as the payload modules rely on the API defined by KEDR, KEDR makes no difference between the payloads provided with it and the ones supplied by the user.
    </p><p>
Different payload modules may be used simultaneously as long as they do not provide different replacement functions for one target function.
    </p></dd><dt><a name="fault_simulation"></a><span class="emphasis"><em>Fault simulation</em></span></dt><dd><p>
Fault simulation is one of the many ways to check reliability of a target kernel module. It can be used, among other things, to see if the target module behaves correctly when the operating system fails to complete some of its requests. For example, you may want to find out if the target module crashes the system when there is not enough memory for its operations or if there is no contiguous memory block of a size greater than N, etc. 
    </p><p>
KEDR allows to perform fault simulation on the target module. The scenarios (which function calls to make fail and in what conditions) can be provided and configured by the user as well. A number of common scenarios is already supported by KEDR by default.
    </p><p>
The fault simulation scenarios are defined by the <a class="link" href="kedr_manual_glossary.html#fault_simulation_point">fault simulation points</a> (<span class="quote">“<span class="quote">What to make fail?</span>”</span>) and <a class="link" href="kedr_manual_glossary.html#fault_simulation_indicator">fault simulation indicators</a> (<span class="quote">“<span class="quote">In what conditions should this fail?</span>”</span>).
    </p></dd><dt><a name="fault_simulation_point"></a><span class="emphasis"><em>Fault simulation point</em></span></dt><dd><p>
Fault simulation point is a location in a kernel module where it should be decided whether to continue execution as usual (<span class="quote">“<span class="quote">normal path</span>”</span>) or go to a path provided to handle an error of some kind (<span class="quote">“<span class="quote">error path</span>”</span>) or something else. This is similar to an ordinary conditional construct in a module. The decision, however, is made based on some predefined scenario rather than on the actual presence of the error conditions. 
    </p><p>
A scenario for a simulation point may be contrived. Sometimes, it does not even take into account whether the normal path and the error path are possible. For example, the default memory allocation manager may return error only if there is no memory chunk of appropriate size. A custom allocation manager, however, may contain a fault simulation point with a scenario that additionally prescribes to make every second allocation  request fail, no matter the requested size.
    </p><p>
In KEDR, fault simulation points are used in the replacement functions. This allows to simulate failures of the target functions according to user-defined scenarios and to see if the target kernel module handles these failures properly (see <a class="xref" href="kedr_manual_glossary.html#fault_simulation"><span class="emphasis"><em>Fault simulation</em></span></a>). In the normal operation of the target module, such failures can be very rare. Therefore, errors in handling of these failures can be harder to notice and debug. KEDR facilitates checking such paths in the target module.
    </p></dd><dt><a name="fault_simulation_indicator"></a><span class="emphasis"><em>Fault simulation indicator</em></span></dt><dd><p>
A fault simulation indicator is usually a function used in a <a class="link" href="kedr_manual_glossary.html#fault_simulation_point">fault simulation point</a> to make a decision, whether to execute <span class="quote">“<span class="quote">normal</span>”</span> or <span class="quote">“<span class="quote">error path</span>”</span> in the code. More often than not, it is a boolean function which returns values corresponding to <span class="quote">“<span class="quote">make fail</span>”</span> and <span class="quote">“<span class="quote">do not make fail</span>”</span> decisions. One might say that an indicator implements the scenario for a fault simulation point (i.e., it answers to the question, <span class="quote">“<span class="quote">In what conditions should this fail?</span>”</span>). 
    </p><p>
In KEDR, fault simulation points and indicators are largely independent on one another. That is, a fault simulation point may use almost any indicator and the indicator can be easily changed at runtime. The only restriction is that if an indicator expects some parameters from the point, the indicator can not be set for the point that does not provide these parameters. For example, consider an indicator implementing the following scenario <span class="quote">“<span class="quote">make this fail if <code class="code">size</code> parameter is greater than 1024</span>”</span>. If a particular fault simulation point corresponding to some target function has nothing like <code class="code">size</code> parameter, KEDR will not allow to use that indicator for this point (it makes no sense anyway).
    </p></dd></dl></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="kedr_manual_reference.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">6. KEDR Reference </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
